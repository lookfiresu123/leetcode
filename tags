!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
BLOCKCOLSIZE	valid_sudoku.c	7;"	d	file:
BLOCKROWSIZE	valid_sudoku.c	6;"	d	file:
Element	word_pattern.cpp	/^    Element(char ch, string &s) : p_char(ch), s_str(s) {}$/;"	f	struct:Element
Element	word_pattern.cpp	/^struct Element {$/;"	s	file:
FrontBackSplit	sort_list.c	/^void FrontBackSplit(struct ListNode* source,  struct ListNode** frontRef, struct ListNode** backRef){$/;"	f
LIMIT	reverse_integer.c	5;"	d	file:
LIMIT_min	reverse_integer.c	6;"	d	file:
ListNode	delete_node_linked_list.c	/^struct ListNode {$/;"	s	file:
ListNode	intersection_of_two_links.c	/^struct ListNode {$/;"	s	file:
ListNode	merge_two_sorted_lists.c	/^struct ListNode {$/;"	s	file:
ListNode	odd_even_linked_list.cpp	/^    ListNode(int x) : val(x), next(NULL) {}$/;"	f	struct:ListNode
ListNode	odd_even_linked_list.cpp	/^struct ListNode {$/;"	s	file:
ListNode	palindrome_linked_list.c	/^struct ListNode {$/;"	s	file:
ListNode	remove_duplicates_from_sorted_list.c	/^struct ListNode {$/;"	s	file:
ListNode	remove_linked_list_elements.c	/^struct ListNode{$/;"	s	file:
ListNode	remove_nth_node_end_list.c	/^struct ListNode {$/;"	s	file:
ListNode	reverse_linked_list.c	/^struct ListNode {$/;"	s	file:
ListNode	sort_list.c	/^struct ListNode {$/;"	s	file:
MinStack	min_stack.cpp	/^    MinStack() {$/;"	f	class:MinStack
MinStack	min_stack.cpp	/^class MinStack {$/;"	c	file:
N	string_to_integer.c	6;"	d	file:
NODE	valid_sudoku.c	/^struct NODE {$/;"	s	file:
Node	valid_sudoku.c	/^typedef struct NODE Node;$/;"	t	typeref:struct:NODE	file:
NumArray	range_sum_query.cpp	/^    NumArray(vector<int> &nums) {$/;"	f	class:NumArray
NumArray	range_sum_query.cpp	/^class NumArray {$/;"	c	file:
Queue	implement_queue_using_stacks.cpp	/^class Queue {$/;"	c	file:
SIZE	plus_one.c	11;"	d	file:
SIZE	valid_sudoku.c	5;"	d	file:
Solution	binary_tree_level_order_traversal.cpp	/^class Solution {$/;"	c	file:
Solution	binary_tree_level_order_traversal_2.cpp	/^class Solution {$/;"	c	file:
Solution	binary_tree_paths.cpp	/^class Solution {$/;"	c	file:
Solution	bulls_and_cows.cpp	/^class Solution {$/;"	c	file:
Solution	construct_tree_postorder_inorder.cpp	/^class Solution {$/;"	c	file:
Solution	construct_tree_preorder_inorder.cpp	/^class Solution {$/;"	c	file:
Solution	contains_duplicate.cpp	/^class Solution {$/;"	c	file:
Solution	count_and_say.cpp	/^class Solution {$/;"	c	file:
Solution	first_bad_version.cpp	/^class Solution {$/;"	c	file:
Solution	house_robber.cpp	/^class Solution {$/;"	c	file:
Solution	is_power_of_three.cpp	/^class Solution {$/;"	c	file:
Solution	lowest_common_ancestor.cpp	/^class Solution {$/;"	c	file:
Solution	odd_even_linked_list.cpp	/^class Solution {$/;"	c	file:
Solution	pascal_triangle.cpp	/^class Solution {$/;"	c	file:
Solution	pascal_triangle_2.cpp	/^class Solution {$/;"	c	file:
Solution	single_number.cpp	/^class Solution {$/;"	c	file:
Solution	strStr.cpp	/^class Solution {$/;"	c	file:
Solution	symmetric_tree.cpp	/^class Solution {$/;"	c	file:
Solution	valid_palindrome.cpp	/^class Solution {$/;"	c	file:
Solution	valid_parentheses.cpp	/^class Solution {$/;"	c	file:
Solution	word_pattern.cpp	/^class Solution {$/;"	c	file:
Stack	implement_stacks_using_queue.cpp	/^class Stack {$/;"	c	file:
TreeNode	balanced_binary_tree.c	/^struct TreeNode {$/;"	s	file:
TreeNode	binary_tree_level_order_traversal.cpp	/^    TreeNode(int x) : val(x), left(NULL), right(NULL) {}$/;"	f	struct:TreeNode
TreeNode	binary_tree_level_order_traversal.cpp	/^struct TreeNode {$/;"	s	file:
TreeNode	binary_tree_level_order_traversal_2.cpp	/^    TreeNode(int x) : val(x), left(NULL), right(NULL) {}$/;"	f	struct:TreeNode
TreeNode	binary_tree_level_order_traversal_2.cpp	/^struct TreeNode {$/;"	s	file:
TreeNode	binary_tree_paths.cpp	/^    TreeNode(int x) : val(x), left(NULL), right(NULL) {}$/;"	f	struct:TreeNode
TreeNode	binary_tree_paths.cpp	/^struct TreeNode {$/;"	s	file:
TreeNode	construct_tree_postorder_inorder.cpp	/^    TreeNode(int x) : val(x), left(NULL), right(NULL) {}$/;"	f	struct:TreeNode
TreeNode	construct_tree_postorder_inorder.cpp	/^struct TreeNode {$/;"	s	file:
TreeNode	construct_tree_preorder_inorder.cpp	/^    TreeNode(int x) : val(x), left(NULL), right(NULL) {}$/;"	f	struct:TreeNode
TreeNode	construct_tree_preorder_inorder.cpp	/^struct TreeNode {$/;"	s	file:
TreeNode	invert_binary_tree.c	/^struct TreeNode {$/;"	s	file:
TreeNode	lowest_common_ancestor.cpp	/^    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}$/;"	f	struct:TreeNode
TreeNode	lowest_common_ancestor.cpp	/^struct TreeNode {$/;"	s	file:
TreeNode	max_depth_of_binary_tree.c	/^struct TreeNode {$/;"	s	file:
TreeNode	minimum_depth_of_binary_tree.c	/^struct TreeNode {$/;"	s	file:
TreeNode	path_sum.c	/^struct TreeNode {$/;"	s	file:
TreeNode	same_tree.c	/^struct TreeNode {$/;"	s	file:
TreeNode	symmetric_tree.cpp	/^    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}$/;"	f	struct:TreeNode
TreeNode	symmetric_tree.cpp	/^struct TreeNode {$/;"	s	file:
adapt_for_digits	compare_version_numbers.c	/^void adapt_for_digits(char *str1, char *str2,char *format_version1,char *format_version2){$/;"	f
addBinary	add_binary.c	/^char* addBinary(char* a, char* b) {$/;"	f
addDigits	add_digits.c	/^int addDigits(int num) {$/;"	f
add_contain_n	compare_version_numbers.c	/^char *add_contain_n(char *str,int n){$/;"	f
add_digits	pascal_triangle.cpp	/^    vector<int> add_digits(int level, vector<int> &previous) {$/;"	f	class:Solution
add_digits_n	compare_version_numbers.c	/^char *add_digits_n(char *start_dest,int n){$/;"	f
add_remain	compare_version_numbers.c	/^char *add_remain(char *start_dest,char *start_source,char *end_source){$/;"	f
binaryTreePaths	binary_tree_paths.cpp	/^    vector<string> binaryTreePaths(TreeNode* root) {$/;"	f	class:Solution
buf_size	summary_ranges.c	10;"	d	file:
buildTree	construct_tree_postorder_inorder.cpp	/^    TreeNode* buildTree(vector<int> &inorder, vector<int>& postorder) {$/;"	f	class:Solution
buildTree	construct_tree_preorder_inorder.cpp	/^    TreeNode* buildTree(vector<int> &preorder, vector<int>& inorder) {$/;"	f	class:Solution
buildTree_helper	construct_tree_postorder_inorder.cpp	/^    TreeNode *buildTree_helper(vector<int>::iterator begin_postorder, vector<int>::iterator end_postorder,$/;"	f	class:Solution
buildTree_helper	construct_tree_preorder_inorder.cpp	/^    TreeNode *buildTree_helper(vector<int>::iterator begin_preorder, vector<int>::iterator end_preorder,$/;"	f	class:Solution
cal_nums_contain	compare_version_numbers.c	/^int cal_nums_contain(char *str){$/;"	f
climbStairs	climbing_stairs.c	/^int climbStairs (int n) {$/;"	f
compare	compare_version_numbers.c	/^int compare(char *str1,char *str2){$/;"	f
compare	symmetric_tree.cpp	/^    bool compare(TreeNode *left_node, TreeNode *right_node) {$/;"	f	class:Solution
compareVersion	compare_version_numbers.c	/^int compareVersion(char *version1, char *version2) {$/;"	f
computeArea	rectangle_area.c	/^int computeArea(int A, int B, int C, int D, int E, int F, int G, int H) {$/;"	f
compute_coverd_rectangle	rectangle_area.c	/^int compute_coverd_rectangle(int first_x_min,int first_y_min,int first_x_max,int first_y_max,$/;"	f
compute_first_rectangle	rectangle_area.c	/^int compute_first_rectangle(int first_x_min,int first_y_min,int first_x_max,int first_y_max){$/;"	f
compute_second_rectangle	rectangle_area.c	/^int compute_second_rectangle(int second_x_min,int second_y_min,int second_x_max,int second_y_max){$/;"	f
containsDuplicate	contains_duplicate.cpp	/^    bool containsDuplicate(vector<int>& nums) {$/;"	f	class:Solution
containsNearbyDuplicate	contains_duplicate_II.c	/^bool containsNearbyDuplicate(int* nums, int numsSize, int k) {$/;"	f
convert	zigzag_conversion.c	/^char* convert(char* s, int numRows) {$/;"	f
convertToTitle	excel_sheet_column_title.c	/^char *convertToTitle(int n){$/;"	f
count	valid_sudoku.c	/^    int count;$/;"	m	struct:NODE	file:
countAndSay	count_and_say.cpp	/^    string countAndSay(int n) {$/;"	f	class:Solution
countPrimes	count_primes.c	/^int countPrimes(int n) {$/;"	f
deleteDuplicates	remove_duplicates_from_sorted_list.c	/^struct ListNode *deleteDuplicates(struct ListNode *head) {$/;"	f
deleteNode	delete_node_linked_list.c	/^void deleteNode(struct ListNode* node) {$/;"	f
delete_zero	happy_number.c	/^int delete_zero(int x){$/;"	f
determine	palindrome_linked_list.c	/^bool determine(struct ListNode** head) {$/;"	f
determine_count	range_sum_query.cpp	/^    vector<int>::size_type determine_count(vector<int> &need, vector<int>::size_type low_range, vector<int>::size_type high_range, unsigned base) {$/;"	f	class:NumArray
dfs	binary_tree_paths.cpp	/^    void dfs(TreeNode *root, string temp, vector<string> &vec) {$/;"	f	class:Solution
dic	word_pattern.cpp	/^    vector<Element> dic;    \/\/ 字典$/;"	m	class:Solution	file:
difference	compare_version_numbers.c	7;"	d	file:
dq	implement_queue_using_stacks.cpp	/^    std::deque<int> dq;$/;"	m	class:Queue	file:
dq	implement_stacks_using_queue.cpp	/^    std::deque<int> dq;$/;"	m	class:Stack	file:
empty	implement_queue_using_stacks.cpp	/^    bool empty(void) {$/;"	f	class:Queue
empty	implement_stacks_using_queue.cpp	/^    bool empty() {$/;"	f	class:Stack
find_nums_between_contains	compare_version_numbers.c	/^int find_nums_between_contains(char *start,char *end){$/;"	f
firstBadVersion	first_bad_version.cpp	/^    int firstBadVersion(int n) {$/;"	f	class:Solution
generate	pascal_triangle.cpp	/^    vector<vector<int>> generate(int numRows) {$/;"	f	class:Solution
getHeight	balanced_binary_tree.c	/^int getHeight(struct TreeNode *root) {$/;"	f
getHint	bulls_and_cows.cpp	/^    string getHint(string secret, string guess) {$/;"	f	class:Solution
getIntersectionNode	intersection_of_two_links.c	/^struct ListNode *getIntersectionNode(struct ListNode *headA,struct ListNode *headB) {$/;"	f
getMin	min_stack.cpp	/^    int getMin() {$/;"	f	class:MinStack
getRow	pascal_triangle_2.cpp	/^    vector<int> getRow(int rowIndex) {$/;"	f	class:Solution
get_string	count_and_say.cpp	/^    string get_string(string &s) {$/;"	f	class:Solution
hammingWeight	numbers_of_1_bits.c	/^int hammingWeight(uint32_t n) {$/;"	f
hasPathSum	path_sum.c	/^bool hasPathSum(struct TreeNode* root, int sum) {$/;"	f
high_limit	range_sum_query.cpp	/^    vector<int>::size_type low_limit, high_limit;   \/\/ [1:n]$/;"	m	class:NumArray	file:
hundred_block	range_sum_query.cpp	/^    vector<int> thousand_block, hundred_block, ten_block, one_block;$/;"	m	class:NumArray	file:
init_Temp	valid_sudoku.c	/^void init_Temp (Node *temp, int temp_size) {$/;"	f
insert	lowest_common_ancestor.cpp	/^    TreeNode *insert(int val) {$/;"	f	class:Solution
invertTree	invert_binary_tree.c	/^struct TreeNode* invertTree(struct TreeNode* root) {$/;"	f
isAnagram	valid_anagram.c	/^bool isAnagram(char* s, char* t) {$/;"	f
isBadVersion	first_bad_version.cpp	/^bool isBadVersion(int version) {$/;"	f
isBalanced	balanced_binary_tree.c	/^bool isBalanced(struct TreeNode* root) {$/;"	f
isHappy	happy_number.c	/^bool isHappy(int n) {$/;"	f
isIsomorphic	isomorphic_strings.c	/^bool isIsomorphic(char* s, char* t) {$/;"	f
isPalindrome	palindrome_linked_list.c	/^bool isPalindrome(struct ListNode *head) {$/;"	f
isPalindrome	palindrome_number.c	/^bool isPalindrome(int x) {$/;"	f
isPalindrome	valid_palindrome.cpp	/^    bool isPalindrome(string s) {$/;"	f	class:Solution
isPowerOfThree	is_power_of_three.cpp	/^    bool isPowerOfThree(int n) {$/;"	f	class:Solution
isPowerOfTwo	power_of_two.c	/^bool isPowerOfTwo(int n) {$/;"	f
isSameTree	same_tree.c	/^bool isSameTree(struct TreeNode* p, struct TreeNode* q) {$/;"	f
isSymmetric	symmetric_tree.cpp	/^    bool isSymmetric(TreeNode* root) {$/;"	f	class:Solution
isUgly	ugly_number.c	/^bool isUgly(int num) {$/;"	f
isValid	valid_parentheses.cpp	/^    bool isValid(string s) {$/;"	f	class:Solution
isValidOne	valid_sudoku.c	/^bool isValidOne (char **board, int i, int j, int boardRowSize, int boardColSize) {$/;"	f
isValidOne_block	valid_sudoku.c	/^bool isValidOne_block (char **board, int num_row, int num_col, int blockrowsize, int blockcolsize) {$/;"	f
isValidOne_column	valid_sudoku.c	/^bool isValidOne_column (char **board, int num_col, int boardRowSize) {$/;"	f
isValidOne_row	valid_sudoku.c	/^bool isValidOne_row (char **board, int num_row, int boardColSize) {$/;"	f
isValidSudoku	valid_sudoku.c	/^bool isValidSudoku (char** board, int boardRowSize, int boardColSize) {$/;"	f
left	balanced_binary_tree.c	/^    struct TreeNode *left;$/;"	m	struct:TreeNode	typeref:struct:TreeNode::TreeNode	file:
left	binary_tree_level_order_traversal.cpp	/^    TreeNode *left;$/;"	m	struct:TreeNode	file:
left	binary_tree_level_order_traversal_2.cpp	/^    TreeNode *left;$/;"	m	struct:TreeNode	file:
left	binary_tree_paths.cpp	/^    TreeNode *left;$/;"	m	struct:TreeNode	file:
left	construct_tree_postorder_inorder.cpp	/^    TreeNode *left;$/;"	m	struct:TreeNode	file:
left	construct_tree_preorder_inorder.cpp	/^    TreeNode *left;$/;"	m	struct:TreeNode	file:
left	invert_binary_tree.c	/^     struct TreeNode *left;$/;"	m	struct:TreeNode	typeref:struct:TreeNode::TreeNode	file:
left	lowest_common_ancestor.cpp	/^    TreeNode *left;$/;"	m	struct:TreeNode	file:
left	max_depth_of_binary_tree.c	/^	struct TreeNode *left;$/;"	m	struct:TreeNode	typeref:struct:TreeNode::TreeNode	file:
left	minimum_depth_of_binary_tree.c	/^    struct TreeNode *left;$/;"	m	struct:TreeNode	typeref:struct:TreeNode::TreeNode	file:
left	path_sum.c	/^    struct TreeNode *left;$/;"	m	struct:TreeNode	typeref:struct:TreeNode::TreeNode	file:
left	same_tree.c	/^	struct TreeNode *left;$/;"	m	struct:TreeNode	typeref:struct:TreeNode::TreeNode	file:
left	symmetric_tree.cpp	/^    TreeNode *left;$/;"	m	struct:TreeNode	file:
length	excel_sheet_column_title.c	4;"	d	file:
lengthOfLastWord	length_of_last_word.c	/^int lengthOfLastWord(char* s) {$/;"	f
length_ascii	isomorphic_strings.c	6;"	d	file:
length_version	compare_version_numbers.c	5;"	d	file:
levelOrder	binary_tree_level_order_traversal.cpp	/^    vector<vector<int>> levelOrder(TreeNode *root) {$/;"	f	class:Solution
levelOrderBottom	binary_tree_level_order_traversal_2.cpp	/^    vector<vector<int>> levelOrderBottom(TreeNode *root) {$/;"	f	class:Solution
longestCommonPrefix	longest_common_prefix.c	/^char* longestCommonPrefix(char** strs, int strsSize) {$/;"	f
low_limit	range_sum_query.cpp	/^    vector<int>::size_type low_limit, high_limit;   \/\/ [1:n]$/;"	m	class:NumArray	file:
lowestCommonAncestor	lowest_common_ancestor.cpp	/^    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {$/;"	f	class:Solution
main	add_binary.c	/^int main (void) {$/;"	f
main	balanced_binary_tree.c	/^int main (void) {$/;"	f
main	binary_tree_level_order_traversal.cpp	/^int main () {$/;"	f
main	binary_tree_level_order_traversal_2.cpp	/^int main () {$/;"	f
main	bulls_and_cows.cpp	/^int main() {$/;"	f
main	climbing_stairs.c	/^int main (void) {$/;"	f
main	compare_version_numbers.c	/^int main(void){$/;"	f
main	construct_tree_postorder_inorder.cpp	/^int main() {$/;"	f
main	construct_tree_preorder_inorder.cpp	/^int main() {$/;"	f
main	contains_duplicate.cpp	/^int main() {$/;"	f
main	contains_duplicate_II.c	/^int main(void){$/;"	f
main	count_and_say.cpp	/^int main() {$/;"	f
main	count_primes.c	/^int main(void){$/;"	f
main	delete_node_linked_list.c	/^int main(void){$/;"	f
main	excel_sheet_column_number.c	/^int main(void){$/;"	f
main	excel_sheet_column_title.c	/^int main(void){$/;"	f
main	factorial_trailing_zeroes.c	/^int main(void){$/;"	f
main	first_bad_version.cpp	/^int main () {$/;"	f
main	happy_number.c	/^int main(void){$/;"	f
main	house_robber.cpp	/^int main () {$/;"	f
main	is_power_of_three.cpp	/^int main() {$/;"	f
main	isomorphic_strings.c	/^int main(void){$/;"	f
main	length_of_last_word.c	/^int main(void){$/;"	f
main	longest_common_prefix.c	/^int main(void){$/;"	f
main	lowest_common_ancestor.cpp	/^int main () {$/;"	f
main	majority_element.c	/^int main(void){$/;"	f
main	maximum_subarray.c	/^int main (void) {$/;"	f
main	merge_sorted_array.c	/^int main (void) {$/;"	f
main	merge_two_sorted_lists.c	/^int main (void) {$/;"	f
main	move_zeroes.c	/^int main (void) {$/;"	f
main	numbers_of_1_bits.c	/^int main(void){$/;"	f
main	odd_even_linked_list.cpp	/^int main () {$/;"	f
main	palindrome_linked_list.c	/^int main(){$/;"	f
main	palindrome_number.c	/^int main(){$/;"	f
main	pascal_triangle.cpp	/^int main() {$/;"	f
main	pascal_triangle_2.cpp	/^int main() {$/;"	f
main	plus_one.c	/^int main(void) {$/;"	f
main	power_of_two.c	/^int main(void){$/;"	f
main	range_sum_query.cpp	/^int main() {$/;"	f
main	rectangle_area.c	/^int main(){$/;"	f
main	remove_duplicates_from_sorted_array.c	/^int main (void) {$/;"	f
main	remove_duplicates_from_sorted_list.c	/^int main (void) {$/;"	f
main	remove_element.c	/^int main(void) {$/;"	f
main	remove_linked_list_elements.c	/^int main(void){$/;"	f
main	remove_nth_node_end_list.c	/^int main(void){$/;"	f
main	reverse_bits.c	/^int main(void){$/;"	f
main	reverse_integer.c	/^int main(void){$/;"	f
main	reverse_linked_list.c	/^int main(void){$/;"	f
main	rotate_array.c	/^int main(void){$/;"	f
main	sort_colors.c	/^int main (void) {$/;"	f
main	sort_list.c	/^int main(void){$/;"	f
main	strStr.cpp	/^int main () {$/;"	f
main	string_to_integer.c	/^int main (void) {$/;"	f
main	summary_ranges.c	/^int main(){$/;"	f
main	ugly_number.c	/^int main (void) {$/;"	f
main	valid_palindrome.cpp	/^int main() {$/;"	f
main	valid_parentheses.cpp	/^int main () {$/;"	f
main	wiggle_sort_2.c	/^int main (void) {$/;"	f
main	word_pattern.cpp	/^int main () {$/;"	f
main	zigzag_conversion.c	/^int main(void){$/;"	f
majorityElement	majority_element.c	/^int majorityElement(int* nums, int numsSize) {$/;"	f
make_happy	happy_number.c	/^int make_happy(int y){$/;"	f
max	balanced_binary_tree.c	13;"	d	file:
max	count_primes.c	6;"	d	file:
max	happy_number.c	5;"	d	file:
maxDepth	max_depth_of_binary_tree.c	/^int maxDepth(struct TreeNode* root) {$/;"	f
maxSubArray	maximum_subarray.c	/^int maxSubArray (int *nums, int numsSize) {$/;"	f
merge	merge_sorted_array.c	/^void merge(int* nums1, int m, int* nums2, int n) {$/;"	f
mergeTwoLists	merge_two_sorted_lists.c	/^struct ListNode* mergeTwoLists(struct ListNode* l1, struct ListNode* l2) {$/;"	f
mergesort	sort_list.c	/^void mergesort(struct ListNode** headref) {$/;"	f
min	min_stack.cpp	/^    std::vector<int> min;$/;"	m	class:MinStack	file:
minDepth	minimum_depth_of_binary_tree.c	/^int minDepth(struct TreeNode* root){$/;"	f
moveZeroes	move_zeroes.c	/^void moveZeroes(int* nums, int numsSize) {$/;"	f
myAtoi	string_to_integer.c	/^int myAtoi(char* str) {$/;"	f
next	delete_node_linked_list.c	/^    struct ListNode *next;$/;"	m	struct:ListNode	typeref:struct:ListNode::ListNode	file:
next	intersection_of_two_links.c	/^    struct ListNode *next;$/;"	m	struct:ListNode	typeref:struct:ListNode::ListNode	file:
next	merge_two_sorted_lists.c	/^    struct ListNode *next;$/;"	m	struct:ListNode	typeref:struct:ListNode::ListNode	file:
next	odd_even_linked_list.cpp	/^    ListNode *next;$/;"	m	struct:ListNode	file:
next	palindrome_linked_list.c	/^    struct ListNode *next;$/;"	m	struct:ListNode	typeref:struct:ListNode::ListNode	file:
next	remove_duplicates_from_sorted_list.c	/^    struct ListNode *next;$/;"	m	struct:ListNode	typeref:struct:ListNode::ListNode	file:
next	remove_linked_list_elements.c	/^    struct ListNode *next;$/;"	m	struct:ListNode	typeref:struct:ListNode::ListNode	file:
next	remove_nth_node_end_list.c	/^    struct ListNode *next;$/;"	m	struct:ListNode	typeref:struct:ListNode::ListNode	file:
next	reverse_linked_list.c	/^    struct ListNode *next;$/;"	m	struct:ListNode	typeref:struct:ListNode::ListNode	file:
next	sort_list.c	/^    struct ListNode *next;$/;"	m	struct:ListNode	typeref:struct:ListNode::ListNode	file:
oddEvenList	odd_even_linked_list.cpp	/^    ListNode* oddEvenList(ListNode* head) {$/;"	f	class:Solution
one_block	range_sum_query.cpp	/^    vector<int> thousand_block, hundred_block, ten_block, one_block;$/;"	m	class:NumArray	file:
p_char	word_pattern.cpp	/^    char p_char;    \/\/ pattern's char$/;"	m	struct:Element	file:
peek	implement_queue_using_stacks.cpp	/^    int peek(void) {$/;"	f	class:Queue
plusOne	plus_one.c	/^int* plusOne(int* digits, int digitsSize, int* returnSize) {$/;"	f
pop	implement_queue_using_stacks.cpp	/^    void pop(void) {$/;"	f	class:Queue
pop	implement_stacks_using_queue.cpp	/^    void pop() {$/;"	f	class:Stack
pop	min_stack.cpp	/^    void pop() {$/;"	f	class:MinStack
push	implement_queue_using_stacks.cpp	/^    void push(int x) {$/;"	f	class:Queue
push	implement_stacks_using_queue.cpp	/^    void push(int x) {$/;"	f	class:Stack
push	min_stack.cpp	/^    void push(int x) {$/;"	f	class:MinStack
removeDuplicates	remove_duplicates_from_sorted_array.c	/^int removeDuplicates (int *nums, int numSize) {$/;"	f
removeElement	remove_element.c	/^int removeElement(int* nums, int numsSize, int val) {$/;"	f
removeElements	remove_linked_list_elements.c	/^struct ListNode* removeElements(struct ListNode* head, int val) {$/;"	f
removeNthFromEnd	remove_nth_node_end_list.c	/^struct ListNode* removeNthFromEnd(struct ListNode* head, int n) {$/;"	f
replace	reverse_linked_list.c	/^void replace(struct ListNode* current){$/;"	f
reverse	reverse_integer.c	/^int reverse(int x) {$/;"	f
reverseBits	reverse_bits.c	/^uint32_t reverseBits(uint32_t n) {$/;"	f
reverseList	reverse_linked_list.c	/^struct ListNode* reverseList(struct ListNode* head) {$/;"	f
right	balanced_binary_tree.c	/^    struct TreeNode *right;$/;"	m	struct:TreeNode	typeref:struct:TreeNode::TreeNode	file:
right	binary_tree_level_order_traversal.cpp	/^    TreeNode *right;$/;"	m	struct:TreeNode	file:
right	binary_tree_level_order_traversal_2.cpp	/^    TreeNode *right;$/;"	m	struct:TreeNode	file:
right	binary_tree_paths.cpp	/^    TreeNode *right;$/;"	m	struct:TreeNode	file:
right	construct_tree_postorder_inorder.cpp	/^    TreeNode *right;$/;"	m	struct:TreeNode	file:
right	construct_tree_preorder_inorder.cpp	/^    TreeNode *right;$/;"	m	struct:TreeNode	file:
right	invert_binary_tree.c	/^     struct TreeNode *right;$/;"	m	struct:TreeNode	typeref:struct:TreeNode::TreeNode	file:
right	lowest_common_ancestor.cpp	/^    TreeNode *right;$/;"	m	struct:TreeNode	file:
right	max_depth_of_binary_tree.c	/^	struct TreeNode *right;$/;"	m	struct:TreeNode	typeref:struct:TreeNode::TreeNode	file:
right	minimum_depth_of_binary_tree.c	/^    struct TreeNode *right;$/;"	m	struct:TreeNode	typeref:struct:TreeNode::TreeNode	file:
right	path_sum.c	/^    struct TreeNode *right;$/;"	m	struct:TreeNode	typeref:struct:TreeNode::TreeNode	file:
right	same_tree.c	/^	struct TreeNode *right;$/;"	m	struct:TreeNode	typeref:struct:TreeNode::TreeNode	file:
right	symmetric_tree.cpp	/^    TreeNode *right;$/;"	m	struct:TreeNode	file:
rob	house_robber.cpp	/^    int rob(vector<int> &nums) {$/;"	f	class:Solution
rotate	rotate_array.c	/^void rotate(int* nums, int numsSize, int k) {$/;"	f
s_str	word_pattern.cpp	/^    string s_str;    \/\/ str's word$/;"	m	struct:Element	file:
scale	excel_sheet_column_number.c	4;"	d	file:
scale	excel_sheet_column_title.c	5;"	d	file:
search_path_for	lowest_common_ancestor.cpp	/^    bool search_path_for(TreeNode *current_root, TreeNode *target, vector<TreeNode *> &target_path) {$/;"	f	class:Solution
singleNumber	single_number.cpp	/^    int singleNumber(vector<int>& nums) {$/;"	f	class:Solution
size	first_bad_version.cpp	/^const size_t size = 2;$/;"	v
size_byte	reverse_bits.c	5;"	d	file:
size_int	palindrome_number.c	5;"	d	file:
sortColors	sort_colors.c	/^void sortColors(int* nums, int numsSize) {$/;"	f
sortList	sort_list.c	/^struct ListNode* sortList(struct ListNode* head) {$/;"	f
sortedMerge	sort_list.c	/^struct ListNode *sortedMerge(struct ListNode *a,struct ListNode *b){$/;"	f
stk	valid_parentheses.cpp	/^    stack<char> stk;$/;"	m	class:Solution	file:
store_next	reverse_linked_list.c	/^int store_next;$/;"	v
store_prev	reverse_linked_list.c	/^int store_prev;$/;"	v
strStr	strStr.cpp	/^    int strStr(string haystack, string needle) {$/;"	f	class:Solution
sumRange	range_sum_query.cpp	/^    int sumRange(int i, int j) {$/;"	f	class:NumArray
sum_range	range_sum_query.cpp	/^    int sum_range(vector<int> &nums, vector<int>::size_type low_range, vector<int>::size_type high_range) {$/;"	f	class:NumArray
summaryRanges	summary_ranges.c	/^char** summaryRanges(int* nums, int numsSize, int* returnSize) {$/;"	f
ten_block	range_sum_query.cpp	/^    vector<int> thousand_block, hundred_block, ten_block, one_block;$/;"	m	class:NumArray	file:
thousand_block	range_sum_query.cpp	/^    vector<int> thousand_block, hundred_block, ten_block, one_block;$/;"	m	class:NumArray	file:
titleToNumber	excel_sheet_column_number.c	/^int titleToNumber(char* s) {$/;"	f
top	implement_stacks_using_queue.cpp	/^    int top() {$/;"	f	class:Stack
top	min_stack.cpp	/^    int top() {$/;"	f	class:MinStack
trailingZeroes	factorial_trailing_zeroes.c	/^int trailingZeroes(int n) {$/;"	f
val	balanced_binary_tree.c	/^    int val;$/;"	m	struct:TreeNode	file:
val	binary_tree_level_order_traversal.cpp	/^    int val;$/;"	m	struct:TreeNode	file:
val	binary_tree_level_order_traversal_2.cpp	/^    int val;$/;"	m	struct:TreeNode	file:
val	binary_tree_paths.cpp	/^    int val;$/;"	m	struct:TreeNode	file:
val	construct_tree_postorder_inorder.cpp	/^    int val;$/;"	m	struct:TreeNode	file:
val	construct_tree_preorder_inorder.cpp	/^    int val;$/;"	m	struct:TreeNode	file:
val	delete_node_linked_list.c	/^    int val;$/;"	m	struct:ListNode	file:
val	intersection_of_two_links.c	/^    int val;$/;"	m	struct:ListNode	file:
val	invert_binary_tree.c	/^     int val;$/;"	m	struct:TreeNode	file:
val	lowest_common_ancestor.cpp	/^    int val;$/;"	m	struct:TreeNode	file:
val	max_depth_of_binary_tree.c	/^	int val;$/;"	m	struct:TreeNode	file:
val	merge_two_sorted_lists.c	/^    int val;$/;"	m	struct:ListNode	file:
val	minimum_depth_of_binary_tree.c	/^    int val;$/;"	m	struct:TreeNode	file:
val	odd_even_linked_list.cpp	/^    int val;$/;"	m	struct:ListNode	file:
val	palindrome_linked_list.c	/^    int val;$/;"	m	struct:ListNode	file:
val	path_sum.c	/^    int val;$/;"	m	struct:TreeNode	file:
val	remove_duplicates_from_sorted_list.c	/^    int val;$/;"	m	struct:ListNode	file:
val	remove_linked_list_elements.c	/^    int val;$/;"	m	struct:ListNode	file:
val	remove_nth_node_end_list.c	/^    int val;$/;"	m	struct:ListNode	file:
val	reverse_linked_list.c	/^    int val;$/;"	m	struct:ListNode	file:
val	same_tree.c	/^	int val;$/;"	m	struct:TreeNode	file:
val	sort_list.c	/^    int val;$/;"	m	struct:ListNode	file:
val	symmetric_tree.cpp	/^    int val;$/;"	m	struct:TreeNode	file:
value	valid_sudoku.c	/^    char value;$/;"	m	struct:NODE	file:
vec	min_stack.cpp	/^    std::vector<int> vec;$/;"	m	class:MinStack	file:
vec	word_pattern.cpp	/^    vector<Element> vec;    \/\/ 存储容器$/;"	m	class:Solution	file:
versions	first_bad_version.cpp	/^static bool versions[size] = {false, false};$/;"	v	file:
wiggleSort	wiggle_sort_2.c	/^void wiggleSort(int *nums, int numsSize) {$/;"	f
wordPattern	word_pattern.cpp	/^    bool wordPattern(string pattern, string str) {$/;"	f	class:Solution
